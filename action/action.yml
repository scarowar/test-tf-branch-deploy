name: "Terrachops"

description: "A reusable composite action for streamlined, IssueOps-driven Terraform deployments."
author: "Scarowar"

branding:
  icon: "terminal"
  color: "purple"

inputs:
  github-token:
    description: "The GitHub token for authentication."
    required: true
  terraform-version:
    description: "The version of Terraform to install."
    required: false
    default: "latest"
  working-directory:
    description: "The path to the Terraform code."
    required: false
    default: "."
  noop-trigger:
    description: "The comment trigger for a terraform plan."
    required: false
    default: ".tf plan"
  trigger:
    description: "The comment trigger for a terraform apply."
    required: false
    default: ".tf apply"
  stable_branch:
    description: "The name of the stable branch for rollback deployments."
    required: false
    default: "main"
  skip-sparse-checkout:
    description: "Skip the sparse checkout step (for local testing)"
    required: false
    default: "false"
  log-level:
    description: "Set the logging level for the action. (DEBUG, INFO, WARNING, ERROR)"
    required: false
    default: "INFO"

runs:
  using: "composite"
  steps:
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.x"
    - name: Install yq
      run: |
        set -euo pipefail
        YQ_VERSION="v4.44.1"
        ARCH=$(uname -m)
        if [ "$ARCH" = "x86_64" ]; then ARCH=amd64; fi
        wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_${ARCH}"
        chmod +x /usr/local/bin/yq
        yq --version
      shell: bash

    - name: Checkout Config File
      if: inputs.skip-sparse-checkout != 'true'
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          .terrachops.yml
        sparse-checkout-cone-mode: false
        ref: ${{ github.event.repository.default_branch }}

    - name: Pre-flight Checks
      id: preflight
      run: |
        set -euo pipefail
        if [ -f ".terrachops.yml" ]; then
          ENVS=$(yq e '.environments | keys | .[]' .terrachops.yml | tr '\n' ',' | sed 's/,$//')
          echo "Discovered environments: $ENVS"
          echo "available_envs=${ENVS}" >> "$GITHUB_OUTPUT"
        else
          echo "available_envs=" >> "$GITHUB_OUTPUT"
        fi
      shell: bash

    - name: Copy deployment message template
      if: steps.branch-deploy.outputs.continue == 'true'
      run: cp ${{ github.action_path }}/deployment_message.template.md ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
      shell: bash

    - name: "IssueOps Command Dispatcher"
      id: branch-deploy
      uses: github/branch-deploy@e837cad62fcc6f5f45997baafd69c57ea9b0641d
      with:
        github_token: ${{ inputs.github-token }}
        noop_trigger: ${{ inputs.noop-trigger }}
        trigger: ${{ inputs.trigger }}
        environment_targets: "${{ steps.preflight.outputs.available_envs || 'production' }}"
        stable_branch: ${{ inputs.stable_branch }}
        deploy_message_path: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md

    - name: Checkout Code
      if: steps.branch-deploy.outputs.continue == 'true'
      uses: actions/checkout@v4
      with:
        ref: ${{ steps.branch-deploy.outputs.sha }}
        fetch-depth: 0

    - name: Ensure prepare_terrachops.py is executable
      if: steps.branch-deploy.outputs.continue == 'true'
      run: |
        set -euo pipefail
        chmod +x ${{ github.action_path }}/scripts/prepare_terrachops.py
      shell: bash

    - name: Prepare Terrachops Commands
      if: steps.branch-deploy.outputs.continue == 'true'
      id: prepare_cmds
      env:
        LOG_LEVEL: ${{ inputs.log-level }}
      run: |
        set -euo pipefail
        pip install -r ${{ github.action_path }}/scripts/requirements.txt

        python ${{ github.action_path }}/scripts/prepare_terrachops.py \
          "${{ inputs.working-directory }}" \
          "${{ steps.branch-deploy.outputs.environment }}" \
          "${{ steps.branch-deploy.outputs.params }}"
      shell: bash

    - name: Setup Terraform
      if: steps.branch-deploy.outputs.continue == 'true'
      uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd
      with:
        terraform_version: ${{ inputs.terraform-version }}

    - name: Terraform Init
      if: steps.branch-deploy.outputs.continue == 'true'
      id: init
      run: |
        set -euo pipefail
        terraform init ${{ steps.prepare_cmds.outputs.init_args }}
      shell: bash
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Terraform Format Check
      if: steps.branch-deploy.outputs.continue == 'true'
      id: fmt
      run: |
        set -euo pipefail
        terraform fmt -check
      shell: bash
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Terraform Validate
      if: steps.branch-deploy.outputs.continue == 'true'
      id: validate
      run: |
        set -euo pipefail
        terraform validate
      shell: bash
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Rollback Plan and Apply
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      id: rollback
      run: |
        set -euo pipefail
        echo "ðŸš¨ Performing immediate plan and apply for stable branch rollback."
        terraform plan ${{ steps.prepare_cmds.outputs.plan_args }} -no-color -out=rollback.plan > rollback_plan.txt
        terraform apply -auto-approve ${{ steps.prepare_cmds.outputs.apply_args }} rollback.plan -no-color | tee rollback_apply.txt
      shell: bash
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Terratrash Filter Rollback Apply Output
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/rollback_apply.txt
        output_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/rollback_apply.filtered.txt

    - name: Truncate Filtered Rollback Apply Output for PR Comment
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      id: truncate_rollback
      shell: bash
      run: |
        MAX_COMMENT_SIZE=64000
        FILTERED_APPLY=rollback_apply.filtered.txt
        FILTERED_APPLY_TRUNC=rollback_apply.filtered.trunc.txt
        ARTIFACT_NEEDED=false
        if [ -f "$FILTERED_APPLY" ] && [ $(wc -c < "$FILTERED_APPLY") -gt $MAX_COMMENT_SIZE ]; then
          head -c $MAX_COMMENT_SIZE "$FILTERED_APPLY" > "$FILTERED_APPLY_TRUNC"
          echo "\n---\n:warning: Output truncated. See artifact for full details." >> "$FILTERED_APPLY_TRUNC"
          ARTIFACT_NEEDED=true
        else
          cp "$FILTERED_APPLY" "$FILTERED_APPLY_TRUNC"
        fi
        echo "artifact_needed=$ARTIFACT_NEEDED" >> $GITHUB_OUTPUT
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Upload Rollback Apply Output Artifact
      if: steps.truncate_rollback.outputs.artifact_needed == 'true'
      id: upload_rollback_artifact
      uses: actions/upload-artifact@v4
      with:
        name: rollback-apply-output-${{ steps.branch-deploy.outputs.sha }}
        path: ${{ steps.prepare_cmds.outputs.working_dir }}/rollback_apply.filtered.txt

    - name: Get Rollback Artifact URL
      if: steps.truncate_rollback.outputs.artifact_needed == 'true'
      id: get_rollback_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = process.env.GITHUB_RUN_ID;
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: runId
          });
          const artifact = artifacts.data.artifacts.find(a => a.name === `rollback-apply-output-${{ steps.branch-deploy.outputs.sha }}`);
          if (artifact) {
            core.setOutput('artifact_url', artifact.archive_download_url);
          } else {
            core.setOutput('artifact_url', '');
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: Render Deployment Message with Terratrash (Rollback)
      if: steps.branch-deploy.outputs.ref == inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false'
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/rollback_apply.filtered.trunc.txt
        erb_render_template: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
        erb_render_save_path: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
      env:
        artifact_url: ${{ steps.get_rollback_artifact_url.outputs.artifact_url }}

    - name: Terraform Plan
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      id: plan
      shell: bash
      run: |
        set -euo pipefail
        terraform plan ${{ steps.prepare_cmds.outputs.plan_args }} -no-color -out=tfplan.binary | tee tfplan.txt
        mv tfplan.binary tfplan-${{ steps.branch-deploy.outputs.sha }}.binary
        # Truncate tfplan.txt if too large for PR comment (GitHub max 65536 chars)
        MAX_COMMENT_SIZE=64000
        PLAN_COMMENT=plan_comment.txt
        if [ $(wc -c < tfplan.txt) -gt $MAX_COMMENT_SIZE ]; then
          head -c $MAX_COMMENT_SIZE tfplan.txt > $PLAN_COMMENT
          echo "\n---\n:warning: Output truncated. See full plan in artifact." >> $PLAN_COMMENT
        else
          cp tfplan.txt $PLAN_COMMENT
        fi
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Terratrash Filter Plan Output
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      id: terratrash_plan
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/tfplan.txt
        output_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/tfplan.filtered.txt

    - name: Truncate Filtered Plan Output for PR Comment
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      id: truncate_plan
      shell: bash
      run: |
        MAX_COMMENT_SIZE=64000
        FILTERED_PLAN=tfplan.filtered.txt
        FILTERED_PLAN_TRUNC=tfplan.filtered.trunc.txt
        ARTIFACT_NEEDED=false
        if [ -f "$FILTERED_PLAN" ] && [ $(wc -c < "$FILTERED_PLAN") -gt $MAX_COMMENT_SIZE ]; then
          head -c $MAX_COMMENT_SIZE "$FILTERED_PLAN" > "$FILTERED_PLAN_TRUNC"
          echo "\n---\n:warning: Output truncated. See artifact for full details." >> "$FILTERED_PLAN_TRUNC"
          ARTIFACT_NEEDED=true
        else
          cp "$FILTERED_PLAN" "$FILTERED_PLAN_TRUNC"
        fi
        echo "artifact_needed=$ARTIFACT_NEEDED" >> $GITHUB_OUTPUT
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Upload Plan Output Artifact
      if: steps.truncate_plan.outputs.artifact_needed == 'true'
      id: upload_plan_artifact
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-output-${{ steps.branch-deploy.outputs.sha }}
        path: ${{ steps.prepare_cmds.outputs.working_dir }}/tfplan.filtered.txt

    - name: Get Plan Artifact URL
      if: steps.truncate_plan.outputs.artifact_needed == 'true'
      id: get_plan_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = process.env.GITHUB_RUN_ID;
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: runId
          });
          const artifact = artifacts.data.artifacts.find(a => a.name === `terraform-plan-output-${{ steps.branch-deploy.outputs.sha }}`);
          if (artifact) {
            core.setOutput('artifact_url', artifact.archive_download_url);
          } else {
            core.setOutput('artifact_url', '');
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: Render Deployment Message with Terratrash (Plan)
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/tfplan.filtered.trunc.txt
        erb_render_template: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
        erb_render_save_path: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
      env:
        artifact_url: ${{ steps.get_plan_artifact_url.outputs.artifact_url }}

    - name: Upload Plan Binary Artifact
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-bin-${{ steps.branch-deploy.outputs.sha }}
        path: ${{ steps.prepare_cmds.outputs.working_dir }}/tfplan-${{ steps.branch-deploy.outputs.sha }}.binary

    - name: Tag Commit with Plan Run ID
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'true' }}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail
        TAG_NAME="terrachops/plan/${{ steps.branch-deploy.outputs.environment }}/${{ github.run_id }}/${{ steps.branch-deploy.outputs.sha }}"
        TAG_MESSAGE="Terrachops plan artifact from run ${{ github.run_id }}. Triggered by @${{ github.actor }} on $(date -u)."

        if git rev-parse -q --verify "refs/tags/$TAG_NAME" >/dev/null; then
          echo "Overwriting existing plan tag for this commit."
        fi

        echo "Creating git tag: $TAG_NAME"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -f "$TAG_NAME" "${{ steps.branch-deploy.outputs.sha }}" -m "$TAG_MESSAGE"
        if ! git push -f origin "refs/tags/$TAG_NAME"; then
          echo "::error::Failed to push git tag. Ensure the workflow has 'contents: write' permission."
          exit 1
        fi
      shell: bash

    - name: Find Plan Run ID from Git Tag
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: find_run_id
      run: |
        set -euo pipefail
        git fetch --tags
        COMMIT_SHA="${{ steps.branch-deploy.outputs.sha }}"
        TARGET_ENV="${{ steps.branch-deploy.outputs.environment }}"
        TAG=$(git for-each-ref "refs/tags/terrachops/plan/${TARGET_ENV}/*/${COMMIT_SHA}" --sort=-creatordate --format='%(refname:short)' | head -n 1)
        if [ -z "$TAG" ]; then
          echo "::error::No Terrachops plan tag found for commit $COMMIT_SHA in environment '$TARGET_ENV'. Please run '.tf plan to $TARGET_ENV' first."
          exit 1
        fi

        echo "Found tag: $TAG"
        RUN_ID=$(echo "$TAG" | awk -F/ '{print $4}')

        echo "Extracted RUN_ID: $RUN_ID"
        echo "run_id=${RUN_ID}" >> "$GITHUB_OUTPUT"
      shell: bash

    - name: Download Plan Artifact
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      uses: actions/download-artifact@v4
      with:
        github-token: ${{ inputs.github-token }}
        run-id: ${{ steps.find_run_id.outputs.run_id }}
        name: terraform-plan-bin-${{ steps.branch-deploy.outputs.sha }}
        path: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Terraform Apply
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: apply
      shell: bash
      run: |
        set -euo pipefail
        terraform apply ${{ steps.prepare_cmds.outputs.apply_args }} -no-color -auto-approve tfplan-${{ steps.branch-deploy.outputs.sha }}.binary | tee apply_output.txt
        # Truncate apply_output.txt if too large for PR comment
        MAX_COMMENT_SIZE=64000
        APPLY_COMMENT=apply_comment.txt
        if [ $(wc -c < apply_output.txt) -gt $MAX_COMMENT_SIZE ]; then
          head -c $MAX_COMMENT_SIZE apply_output.txt > $APPLY_COMMENT
          echo "\n---\n:warning: Output truncated. See full apply log in artifact." >> $APPLY_COMMENT
        else
          cp apply_output.txt $APPLY_COMMENT
        fi
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    # APPLY: Filter, then Truncate, then Render
    - name: Terratrash Filter Apply Output
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: terratrash_apply
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/apply_output.txt
        output_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/apply_output.filtered.txt

    - name: Truncate Filtered Apply Output for PR Comment
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      id: truncate_apply
      shell: bash
      run: |
        MAX_COMMENT_SIZE=64000
        FILTERED_APPLY=apply_output.filtered.txt
        FILTERED_APPLY_TRUNC=apply_output.filtered.trunc.txt
        ARTIFACT_NEEDED=false
        if [ -f "$FILTERED_APPLY" ] && [ $(wc -c < "$FILTERED_APPLY") -gt $MAX_COMMENT_SIZE ]; then
          head -c $MAX_COMMENT_SIZE "$FILTERED_APPLY" > "$FILTERED_APPLY_TRUNC"
          echo "\n---\n:warning: Output truncated. See artifact for full details." >> "$FILTERED_APPLY_TRUNC"
          ARTIFACT_NEEDED=true
        else
          cp "$FILTERED_APPLY" "$FILTERED_APPLY_TRUNC"
        fi
        echo "artifact_needed=$ARTIFACT_NEEDED" >> $GITHUB_OUTPUT
      working-directory: ${{ steps.prepare_cmds.outputs.working_dir }}

    - name: Upload Apply Output Artifact
      if: steps.truncate_apply.outputs.artifact_needed == 'true'
      id: upload_apply_artifact
      uses: actions/upload-artifact@v4
      with:
        name: terraform-apply-output-${{ steps.branch-deploy.outputs.sha }}
        path: ${{ steps.prepare_cmds.outputs.working_dir }}/apply_output.filtered.txt

    - name: Get Apply Artifact URL
      if: steps.truncate_apply.outputs.artifact_needed == 'true'
      id: get_apply_artifact_url
      uses: actions/github-script@v7
      with:
        script: |
          const runId = process.env.GITHUB_RUN_ID;
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: runId
          });
          const artifact = artifacts.data.artifacts.find(a => a.name === `terraform-apply-output-${{ steps.branch-deploy.outputs.sha }}`);
          if (artifact) {
            core.setOutput('artifact_url', artifact.archive_download_url);
          } else {
            core.setOutput('artifact_url', '');
          }
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}

    - name: Render Deployment Message with Terratrash (Apply)
      if: ${{ steps.branch-deploy.outputs.ref != inputs.stable_branch && steps.branch-deploy.outputs.noop == 'false' }}
      uses: GrantBirki/terratrash-action@f4b67b8ee0925ff4ed28bd20c44bebbd16e8f892
      with:
        input_file_path: ${{ steps.prepare_cmds.outputs.working_dir }}/apply_output.filtered.trunc.txt
        erb_render_template: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
        erb_render_save_path: ${{ steps.prepare_cmds.outputs.working_dir }}/deployment_message.md
      env:
        artifact_url: ${{ steps.get_apply_artifact_url.outputs.artifact_url }}
